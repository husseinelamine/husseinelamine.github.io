import * as THREE from 'three';
//import { Scene, PerspectiveCamera, WebGLRenderer, AmbientLight, PointLight, HemisphereLight, BoxGeometry, MeshPhongMaterial, Mesh, PlaneGeometry, ShaderMaterial, Vector2, MeshPhysicalMaterial, MeshStandardMaterial } from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let camera, scene, renderer, bulbMat, hemiLight, floorMat, params, hemiLuminousIrradiances, bulbLuminousPowers, uniforms, ico, controls;
let bulbLight, bulbLight2, bulbLight3, bulbLight4;

const element = $("#main-canvas");
const bulbLights = [];
let speed;


start();

function init() {
    // intialize global variables
    speed = 0.5;


    scene = new THREE.Scene();

    bulbLuminousPowers = {
        '110000 lm (1000W)': 110000,
        '3500 lm (300W)': 3500,
        '1700 lm (100W)': 1700,
        '800 lm (60W)': 800,
        '400 lm (40W)': 400,
        '180 lm (25W)': 180,
        '20 lm (4W)': 20,
        'Off': 0
    };

    hemiLuminousIrradiances = {
        '0.0001 lx (Moonless Night)': 0.0001,
        '0.002 lx (Night Airglow)': 0.002,
        '0.5 lx (Full Moon)': 0.5,
        '3.4 lx (City Twilight)': 3.4,
        '50 lx (Living Room)': 50,
        '100 lx (Very Overcast)': 100,
        '350 lx (Office Room)': 350,
        '400 lx (Sunrise/Sunset)': 400,
        '1000 lx (Overcast)': 1000,
        '18000 lx (Daylight)': 18000,
        '50000 lx (Direct Sun)': 50000,
        'Custom': 0.15
    };

    params = {
        shadows: true,
        exposure: 0.68,
        bulbPower: Object.keys(bulbLuminousPowers)[0],
        hemiIrradiance: Object.keys(hemiLuminousIrradiances)[11]
    };

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1, 4);
    camera.lookAt(0,1,0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(element.width(), element.height(), false);
    element.append(renderer.domElement);

    //controls = new OrbitControls(camera, renderer.domElement);

    const ambiantLight = new THREE.AmbientLight(0x404040, 0.3);
    scene.add(ambiantLight);

    const bulbGeometry = new THREE.SphereGeometry(0.02, 16, 8);
    bulbLight = new THREE.PointLight(0xffee88, 1, 100, 2);

    bulbMat = new THREE.MeshStandardMaterial({
        emissive: 0xffffee,
        emissiveIntensity: 1,
        color: 0x111111
    });
    bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
    bulbLight.position.set(0, 2, 0);
    bulbLights[0] = bulbLight;
    scene.add(bulbLight);
    
    const colors = [0xffee88, 0x00ffff, 0xff00ff, 0xffff00];
    const positions = [[0, 2, 0], [4, 2, -1], [-4, 2, -1], [0, 2, 4]];
    bulbLight.color = new THREE.Color(colors[0]);

    for (let i = 1; i < 4; i++) {
        bulbLights[i] = bulbLight.clone();
        bulbLights[i].color = new THREE.Color(colors[i]);
        bulbLights[i].position.set(...positions[i]);
        scene.add(bulbLights[i]);
    }

    hemiLight = new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, hemiLuminousIrradiances[params.hemiIrradiance]);
    scene.add(hemiLight);

    floorMat = new THREE.MeshStandardMaterial({
        roughness: 0.8,
        color: 0xffffff,
        metalness: 0.2,
        bumpScale: 1
    });

    const roomSize = 5;
    const roomGeometry = new THREE.BoxGeometry(roomSize, roomSize, roomSize);
    const roomMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, side: THREE.BackSide });
    const room = new THREE.Mesh(roomGeometry, roomMaterial);
    scene.add(room);

    const floorGeometry = new THREE.BoxGeometry(5, 5, 0.1);
    const floorMesh = new THREE.Mesh(floorGeometry, floorMat);
    floorMesh.receiveShadow = true;
    floorMesh.rotation.x = -Math.PI / 2.0;
    scene.add(floorMesh);


    const firstfloor_halfwall = new THREE.BoxGeometry(5, 2.5, 0.1);
    const firstfloor_halfwallMesh = new THREE.Mesh(firstfloor_halfwall, floorMat);
    firstfloor_halfwallMesh.receiveShadow = true;
    firstfloor_halfwallMesh.rotation.x = 0;
    firstfloor_halfwallMesh.rotation.y = -Math.PI / 2.0;
    firstfloor_halfwallMesh.position.x = 1;
    firstfloor_halfwallMesh.position.y = 1.25;
    firstfloor_halfwallMesh.position.z = -2.5;
    scene.add(firstfloor_halfwallMesh);

    uniforms = {
        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        time: { value: 0.0 }
    };

    const screenGeometry = new THREE.PlaneGeometry(6, 3.375);
    const screenMaterial = new THREE.ShaderMaterial({
        vertexShader: `
            void main() {
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }`,
        fragmentShader: `
            uniform float time;
            uniform vec2 resolution;

            float sdSquare(vec2 p, vec2 sz) {
                vec2 d = abs(p) - sz;
                return min(max(d.x,d.y),0.0) + length(max(d,0.0));
            }
            
            void main() {
                vec2 p = (2.0 * gl_FragCoord.xy - resolution) / min(resolution.x, resolution.y);
                float d = sdSquare(p, vec2(0.5));
                float c = 0.5 + 0.5 * cos(3.0 * time + d * 3.0);
                gl_FragColor = vec4(c, c, c, 1.0);
            }`,
        uniforms: uniforms
    });

    const screen = new THREE.Mesh(screenGeometry, screenMaterial);
    screen.position.set(0, 3, -4);
    scene.add(screen);

    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshPhysicalMaterial({
        metalness: 0.5,
        roughness: 0.5,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1,
        reflectivity: 1.0,
        transmission: 0.5,
        ior: 1.5,
        color: 0x00ff00,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
        shadowSide: THREE.DoubleSide
    });

    ico = new THREE.Mesh(geometry, material);
    ico.position.y = 1;
    ico.position.z = -5;
    ico.castShadow = true;
    ico.receiveShadow = true;
    scene.add(ico);

    document.addEventListener("wheel", (e) => {
        ico.position.z += e.deltaY * 0.01;
        camera.position.y = Math.min(Math.max(camera.position.y - e.deltaY * 0.001, -1.5), 1);
    });

    window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.resolution.value.x = window.innerWidth;
    uniforms.resolution.value.y = window.innerHeight;
}

function start() {
    init();
    animate();
}


// function the takes the time and return an interpolated value between 0.3 and 4 in a non-linear way
function lerp(time) {
    return (Math.sin(time) * 0.5 + 0.5) * 3.7;
}
function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.0005;

    
	bulbLights[0].position.x = Math.sin(speed * lerp(time*0.7)) * 2.4;
	bulbLights[0].position.y = Math.cos(speed * lerp(time*0.5)) * 2.3;
	bulbLights[0].position.z = Math.cos(speed * lerp(time*0.3)) * 2.4;

    bulbLights[1].position.x = Math.sin(speed * lerp(time*0.13)) * 2.4;
    bulbLights[1].position.y = Math.cos(speed * lerp(time*0.5)) * 2.3;
    bulbLights[1].position.z = Math.cos(speed * lerp(time*0.75)) * 2.4;

    bulbLights[2].position.z = Math.cos(speed * lerp(time*0.7)) * 2.4;
    bulbLights[2].position.y = Math.cos(speed * lerp(time*0.6)) * 2.3;
    bulbLights[2].position.x = Math.cos(speed * lerp(time*0.7)) * 2.4;

    bulbLights[3].position.x = Math.cos(speed * lerp(time*0.7)) * 2.3;
    bulbLights[3].position.y = Math.cos(speed * lerp(time*0.5)) * 2.4;
    bulbLights[3].position.z = Math.cos(speed * lerp(time*0.3)) * 2.4;

    ico.rotation.x += 0.001;
    ico.rotation.y += 0.001;
    ico.rotation.z += 0.001;


    uniforms.time.value = time;
    //controls.update();
    renderer.render(scene, camera);
}

function destroy() {
    cancelAnimationFrame(animationRequestId);
    scene.children.forEach(child => scene.remove(child));

    scene.traverse(child => {
        if (child instanceof Mesh) {
            child.geometry.dispose();
            child.material.dispose();
        }
    });
}
